<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Cratis.Fundamentals</name>
    </assembly>
    <members>
        <member name="T:Microsoft.AspNetCore.Builder.BootApplicationBuilderExtensions">
            <summary>
            Represents extension methods for building on <see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/>.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Builder.BootApplicationBuilderExtensions.PerformBootProcedures(Microsoft.AspNetCore.Builder.IApplicationBuilder)">
            <summary>
            Perform all <see cref="T:Cratis.Boot.IPerformBootProcedure">boot procedures</see>.
            </summary>
            <param name="applicationBuilder"><see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/> to add to.</param>
            <returns><see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/> for continuation.</returns>
        </member>
        <member name="T:Microsoft.AspNetCore.Builder.ExecutionContextAppBuilderExtensions">
            <summary>
            Extension methods for <see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/> for the purpose of working with <see cref="T:Cratis.Execution.ExecutionContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Builder.ExecutionContextAppBuilderExtensions.UseExecutionContext(Microsoft.AspNetCore.Builder.IApplicationBuilder)">
            <summary>
            Use execution context for an application.
            </summary>
            <param name="app"><see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/> to use <see cref="T:Cratis.Execution.ExecutionContext"/> for.</param>
            <returns><see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/> for builder continuation.</returns>
            <remarks>
            This adds a middleware that will look for an HTTP header to use as Tenant identifier and establishes
            the correct <see cref="T:Cratis.Execution.ExecutionContext"/> according to this.
            </remarks>
        </member>
        <member name="T:Microsoft.AspNetCore.Builder.WebApplicationBuilderExtensions">
            <summary>
            Represents extension methods for building on <see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/>.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Builder.WebApplicationBuilderExtensions.RunAsSinglePageApplication(Microsoft.AspNetCore.Builder.IApplicationBuilder,Microsoft.AspNetCore.StaticFiles.Infrastructure.SharedOptions)">
            <summary>
            Run as a single page application - typically end off your application configuration in Startup.cs with this.
            </summary>
            <param name="app"><see cref="T:Microsoft.AspNetCore.Builder.IApplicationBuilder"/> you're building.</param>
            <param name="options">Optional <see cref="T:Microsoft.AspNetCore.StaticFiles.Infrastructure.SharedOptions"/> to file that will be sent as the single page.</param>
            <remarks>
            If there is no <see cref="T:Microsoft.AspNetCore.StaticFiles.Infrastructure.SharedOptions"/> given, it will default to index.html inside your wwwwroot of the content root.
            </remarks>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.ConfigurationHostBuilderExtensions">
            <summary>
            Extension methods for setting up configuration for host.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.ConfigurationHostBuilderExtensions.AddConfigurationObjects(Microsoft.Extensions.DependencyInjection.IServiceCollection,Cratis.Types.ITypes,System.String)">
            <summary>
            Use configuration objects through discovery based on objects adorned with <see cref="T:Cratis.Configuration.ConfigurationAttribute"/>.
            </summary>
            <param name="services"><see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> to use with.</param>
            <param name="types"><see cref="T:Cratis.Types.ITypes"/> for type discovery.</param>
            <param name="baseRelativePath">Optional base relative path, relative to the current running directory.</param>
            <returns><see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> for continuation.</returns>
        </member>
        <member name="T:Cratis.Boot.BootProcedures">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Boot.IBootProcedures"/>.
            </summary>
        </member>
        <member name="M:Cratis.Boot.BootProcedures.#ctor(Cratis.Types.IInstancesOf{Cratis.Boot.IPerformBootProcedure})">
            <summary>
            Initializes a new instance of <see cref="T:Cratis.Boot.BootProcedures"/>.
            </summary>
            <param name="procedures"><see cref="T:Cratis.Types.IInstancesOf`1"/> <see cref="T:Cratis.Boot.IPerformBootProcedure"/>.</param>
        </member>
        <member name="M:Cratis.Boot.BootProcedures.Perform">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Boot.IBootProcedures">
            <summary>
            Defines a system that can deal with <see cref="T:Cratis.Boot.IPerformBootProcedure"/>.
            </summary>
        </member>
        <member name="M:Cratis.Boot.IBootProcedures.Perform">
            <summary>
            Perform the boot procedures.
            </summary>
        </member>
        <member name="T:Cratis.Boot.IPerformBootProcedure">
            <summary>
            Marker interface that can be used for a boot procedure that will be called automatically during startup.
            </summary>
        </member>
        <member name="M:Cratis.Boot.IPerformBootProcedure.Perform">
            <summary>
            The method that will be called.
            </summary>
        </member>
        <member name="T:Cratis.Changes.Change">
            <summary>
            Defines a change as part of a <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
            <param name="State">State after change applied.</param>
        </member>
        <member name="M:Cratis.Changes.Change.#ctor(System.Object)">
            <summary>
            Defines a change as part of a <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
            <param name="State">State after change applied.</param>
        </member>
        <member name="T:Cratis.Changes.Changeset`2">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Changes.IChangeset`2"/>.
            </summary>
            <typeparam name="TSource">Type of the source object we are working from.</typeparam>
            <typeparam name="TTarget">Type of target object we are applying changes to.</typeparam>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
            <param name="incoming"><see cref="P:Cratis.Changes.Changeset`2.Incoming"/> that the <see cref="T:Cratis.Changes.Changeset`2"/> is for.</param>
            <param name="initialState">The initial state before any changes are applied.</param>
        </member>
        <member name="P:Cratis.Changes.Changeset`2.Incoming">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Changes.Changeset`2.InitialState">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Changes.Changeset`2.Changes">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Changes.Changeset`2.HasChanges">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.Add(Cratis.Changes.Change)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.SetProperties(System.Collections.Generic.IEnumerable{Cratis.Properties.PropertyMapper{`0,`1}})">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.SetChildProperties``1(``0,Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,Cratis.Properties.ValueProvider{`0},System.Collections.Generic.IEnumerable{Cratis.Properties.PropertyMapper{`0,``0}})">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.AddChild``1(Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,System.Object,System.Collections.Generic.IEnumerable{Cratis.Properties.PropertyMapper{`0,``0}})">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.Remove">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.RemoveChild">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.HasChildBeenAddedWithKey(Cratis.Properties.PropertyPath,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Changes.Changeset`2.GetChildByKey``1(Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Changes.ChildAdded">
            <summary>
            Represents a child that has been added to a parent.
            </summary>
            <param name="Child">State of the object being added.</param>
            <param name="ChildrenProperty">The property holding the children in the parent object.</param>
            <param name="IdentifiedByProperty">The property that identifies the key on the child object.</param>
            <param name="Key">Key of the object.</param>
        </member>
        <member name="M:Cratis.Changes.ChildAdded.#ctor(System.Object,Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,System.Object)">
            <summary>
            Represents a child that has been added to a parent.
            </summary>
            <param name="Child">State of the object being added.</param>
            <param name="ChildrenProperty">The property holding the children in the parent object.</param>
            <param name="IdentifiedByProperty">The property that identifies the key on the child object.</param>
            <param name="Key">Key of the object.</param>
        </member>
        <member name="T:Cratis.Changes.ChildPropertiesChanged`1">
            <summary>
            Represents properties that has been changed on a child.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="State">State after change applied.</param>
            <param name="ChildrenProperty">The property holding the children in the parent object.</param>
            <param name="IdentifiedByProperty">The property that identifies the key on the child object.</param>
            <param name="Key">Key of the object.</param>
            <param name="Differences">The differences between initial state and a change.</param>
        </member>
        <member name="M:Cratis.Changes.ChildPropertiesChanged`1.#ctor(System.Object,Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,System.Object,System.Collections.Generic.IEnumerable{Cratis.Changes.PropertyDifference{`0}})">
            <summary>
            Represents properties that has been changed on a child.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="State">State after change applied.</param>
            <param name="ChildrenProperty">The property holding the children in the parent object.</param>
            <param name="IdentifiedByProperty">The property that identifies the key on the child object.</param>
            <param name="Key">Key of the object.</param>
            <param name="Differences">The differences between initial state and a change.</param>
        </member>
        <member name="T:Cratis.Changes.CollectionExtensions">
            <summary>
            Extension methods for working with collections.
            </summary>
        </member>
        <member name="M:Cratis.Changes.CollectionExtensions.FindByKey``1(System.Collections.Generic.IEnumerable{``0},Cratis.Properties.PropertyPath,System.Object)">
            <summary>
            Find an item in a collection by its identity.
            </summary>
            <typeparam name="TTarget">Target type</typeparam>
            <param name="items">Items to find from.</param>
            <param name="identityProperty"><see cref="T:Cratis.Properties.PropertyPath"/> holding identity on each item.</param>
            <param name="key">The key value to check for.</param>
            <returns>The item or default if not found.</returns>
        </member>
        <member name="M:Cratis.Changes.CollectionExtensions.EnsureCollection``2(``0,Cratis.Properties.PropertyPath)">
            <summary>
            Ensures that a collection exists for a specific <see cref="T:Cratis.Properties.PropertyPath"/>.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <typeparam name="TChild">Type of child for the collection.</typeparam>
            <param name="target">Target object.</param>
            <param name="childrenProperty"><see cref="T:Cratis.Properties.PropertyPath"/> to ensure collection for.</param>
            <returns>The ensured <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
            <exception cref="T:Cratis.Properties.ChildrenPropertyIsNotEnumerable">Thrown if there is an existing property and it is not enumerable.</exception>
        </member>
        <member name="M:Cratis.Changes.CollectionExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},Cratis.Properties.PropertyPath,System.Object)">
            <summary>
            Check if there is an item with a specific key in a collection of <see cref="T:System.Dynamic.ExpandoObject"/> items.
            </summary>
            <typeparam name="TChild">Type of child.</typeparam>
            <param name="items">Items to check.</param>
            <param name="identityProperty"><see cref="T:Cratis.Properties.PropertyPath"/> holding identity on each item.</param>
            <param name="key">The key value to check for.</param>
            <returns>True if there is an item, false if not</returns>
        </member>
        <member name="T:Cratis.Changes.IChangeset`2">
            <summary>
            Represents a changeset of changes that can occur to an object.
            </summary>
            <typeparam name="TSource">Type of the source object we are working from.</typeparam>
            <typeparam name="TTarget">Type of target object we are applying changes to.</typeparam>
        </member>
        <member name="P:Cratis.Changes.IChangeset`2.Incoming">
            <summary>
            Gets the <see cref="P:Cratis.Changes.IChangeset`2.Incoming"/> the <see cref="T:Cratis.Changes.Changeset`2"/> is for.
            </summary>
        </member>
        <member name="P:Cratis.Changes.IChangeset`2.InitialState">
            <summary>
            Gets the initial state of before changes in changeset occurred.
            </summary>
        </member>
        <member name="P:Cratis.Changes.IChangeset`2.Changes">
            <summary>
            Gets all the changes for the changeset.
            </summary>
        </member>
        <member name="P:Cratis.Changes.IChangeset`2.HasChanges">
            <summary>
            Gets whether or not there are changes in the changeset.
            </summary>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.Add(Cratis.Changes.Change)">
            <summary>
            Add a change to the changeset.
            </summary>
            <param name="change"><see cref="T:Cratis.Changes.Change"/> to add.</param>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.SetProperties(System.Collections.Generic.IEnumerable{Cratis.Properties.PropertyMapper{`0,`1}})">
            <summary>
            Applies properties to the <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
            <param name="propertyMappers">Collection of <see cref="T:Cratis.Properties.PropertyMapper`2">property mappers</see> that will manipulate properties on the target.</param>
            <remarks>
            This will run a diff against the initial state and only produce changes that are new.
            </remarks>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.SetChildProperties``1(``0,Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,Cratis.Properties.ValueProvider{`0},System.Collections.Generic.IEnumerable{Cratis.Properties.PropertyMapper{`0,``0}})">
            <summary>
            Applies properties for a child to the <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
            <typeparam name="TChild">Type of child.</typeparam>
            <param name="item">The item to add from.</param>
            <param name="childrenProperty">The <see cref="T:Cratis.Properties.PropertyPath"/> on the parent that holds the children.</param>
            <param name="identifiedByProperty">The <see cref="T:Cratis.Properties.PropertyPath"/> on the instance that identifies the child.</param>
            <param name="keyResolver">The <see cref="T:Cratis.Properties.ValueProvider`1"/> for resolving the key on the event.</param>
            <param name="propertyMappers">Collection of <see cref="T:Cratis.Properties.PropertyMapper`2">property mappers</see> that will manipulate properties on the target.</param>
            <remarks>
            This will run a diff against the initial state and only produce changes that are new.
            </remarks>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.AddChild``1(Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,System.Object,System.Collections.Generic.IEnumerable{Cratis.Properties.PropertyMapper{`0,``0}})">
            <summary>
            Applies properties to the child in the model to the <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
            <typeparam name="TChild">Type of child.</typeparam>
            <param name="childrenProperty"><see cref="T:Cratis.Properties.PropertyPath"/> for accessing the children collection.</param>
            <param name="identifiedByProperty"><see cref="T:Cratis.Properties.PropertyPath"/> that identifies the child.</param>
            <param name="key">Key value.</param>
            <param name="propertyMappers">Collection of <see cref="T:Cratis.Properties.PropertyMapper`2">property mappers</see> that will manipulate properties on the target.</param>
            <exception cref="T:Cratis.Properties.ChildrenPropertyIsNotEnumerable">Thrown when children property is not enumerable.</exception>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.Remove">
            <summary>
            Apply a remove change to the <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.RemoveChild">
            <summary>
            Apply a remove child change to the <see cref="T:Cratis.Changes.Changeset`2"/>.
            </summary>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.HasChildBeenAddedWithKey(Cratis.Properties.PropertyPath,System.Object)">
            <summary>
            Check if changeset contains a <see cref="T:Cratis.Changes.ChildAdded"/> to a collection with a specific key.
            </summary>
            <param name="childrenProperty">The <see cref="T:Cratis.Properties.PropertyPath"/> representing the collection.</param>
            <param name="key">The key of the item.</param>
            <returns>True if it has, false it not.</returns>
        </member>
        <member name="M:Cratis.Changes.IChangeset`2.GetChildByKey``1(Cratis.Properties.PropertyPath,Cratis.Properties.PropertyPath,System.Object)">
            <summary>
            Get a specific child from
            </summary>
            <typeparam name="TChild">Type of child.</typeparam>
            <param name="childrenProperty">The <see cref="T:Cratis.Properties.PropertyPath"/> representing the collection.</param>
            <param name="identifiedByProperty">The <see cref="T:Cratis.Properties.PropertyPath"/> that identifies the child</param>
            <param name="key">The key of the item.</param>
            <returns>The added child.</returns>
        </member>
        <member name="T:Cratis.Changes.PropertiesChanged`1">
            <summary>
            Represents properties that has been changed.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="State">State after change applied.</param>
            <param name="Differences">The differences between initial state and a change.</param>
        </member>
        <member name="M:Cratis.Changes.PropertiesChanged`1.#ctor(System.Object,System.Collections.Generic.IEnumerable{Cratis.Changes.PropertyDifference{`0}})">
            <summary>
            Represents properties that has been changed.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="State">State after change applied.</param>
            <param name="Differences">The differences between initial state and a change.</param>
        </member>
        <member name="T:Cratis.Changes.PropertyDifference`1">
            <summary>
            Represents a value difference in a property of an object.
            </summary>
            <typeparam name="TTarget">Target type the property difference is for.</typeparam>
        </member>
        <member name="M:Cratis.Changes.PropertyDifference`1.#ctor(`0,`0,ObjectsComparer.Difference)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Changes.PropertyDifference`1"/> class.
            </summary>
            <param name="initialInstance">Original state.</param>
            <param name="modifiedInstance">Changed state.</param>
            <param name="difference">Raw difference.</param>
        </member>
        <member name="P:Cratis.Changes.PropertyDifference`1.MemberPath">
            <summary>
            Gets the full member path to the property that has changed.
            </summary>
        </member>
        <member name="P:Cratis.Changes.PropertyDifference`1.Original">
            <summary>
            Gets the original value - possibly default.
            </summary>
        </member>
        <member name="P:Cratis.Changes.PropertyDifference`1.Changed">
            <summary>
            Gets the changed value - possibly default.
            </summary>
        </member>
        <member name="T:Cratis.Changes.RemovePerformed">
            <summary>
            Represents an entry being removed.
            </summary>
            <param name="Key"></param>
        </member>
        <member name="M:Cratis.Changes.RemovePerformed.#ctor(System.Object)">
            <summary>
            Represents an entry being removed.
            </summary>
            <param name="Key"></param>
        </member>
        <member name="T:Cratis.Collections.CollectionsExtensions">
            <summary>
            Provides a set of extension methods for different collection and enumerable types.
            </summary>
        </member>
        <member name="M:Cratis.Collections.CollectionsExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Enumerate an enumerable and call the given Action for each item.
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="enumerable"><see cref="T:System.Collections.Generic.IEnumerable`1"/> to enumerate.</param>
            <param name="action"><see cref="T:System.Action`1"/> to call for each item.</param>
        </member>
        <member name="M:Cratis.Collections.CollectionsExtensions.Combine``2(System.Collections.Generic.IEnumerable{System.Linq.ILookup{``0,``1}})">
            <summary>
            Combines multiple lookups into a single lookup.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TElement">The type of the elements.</typeparam>
            <param name="lookups">A collection of lookups to combine.</param>
            <returns>A single lookup which takes a key into all values with this key in all incoming lookups.</returns>
        </member>
        <member name="T:Cratis.Compliance.ComplianceDetailsAttribute">
            <summary>
            Attribute to adorn for providing the details as to why or to what purpose/extent the type or property marked is classified as PII.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.ComplianceDetailsAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Compliance.ComplianceDetailsAttribute"/> class.
            </summary>
            <param name="details">The details as to why or to what purpose/extent the type or property marked is classified as PII.</param>
        </member>
        <member name="P:Cratis.Compliance.ComplianceDetailsAttribute.Details">
            <summary>
            Gets the details as to why or to what purpose/extent the type or property marked is classified as PII.
            </summary>
        </member>
        <member name="T:Cratis.Compliance.ComplianceDetailsExtensions">
            <summary>
            Extension methods for providing compliance details.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.ComplianceDetailsExtensions.GetComplianceMetadataDetails(System.Type)">
            <summary>
            Get the compliance metadata details from a <see cref="T:System.Type"/>.
            </summary>
            <param name="type">Type to get from.</param>
            <returns>The details - empty string if none is set.</returns>
        </member>
        <member name="M:Cratis.Compliance.ComplianceDetailsExtensions.GetComplianceMetadataDetails(System.Reflection.PropertyInfo)">
            <summary>
            Get the compliance metadata details from a <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="property">Property to get from.</param>
            <returns>The details - empty string if none is set.</returns>
        </member>
        <member name="T:Cratis.Compliance.ComplianceMetadata">
            <summary>
            Represents the metadata related to compliance.
            </summary>
            <param name="Type">The <see cref="T:Cratis.Compliance.ComplianceMetadataType"/>.</param>
            <param name="Details">Any additional details - can be empty.</param>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadata.#ctor(Cratis.Compliance.ComplianceMetadataType,System.String)">
            <summary>
            Represents the metadata related to compliance.
            </summary>
            <param name="Type">The <see cref="T:Cratis.Compliance.ComplianceMetadataType"/>.</param>
            <param name="Details">Any additional details - can be empty.</param>
        </member>
        <member name="T:Cratis.Compliance.ComplianceMetadataResolver">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Compliance.IComplianceMetadataResolver"/>.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataResolver.#ctor(Cratis.Types.IInstancesOf{Cratis.Compliance.ICanProvideComplianceMetadataForType},Cratis.Types.IInstancesOf{Cratis.Compliance.ICanProvideComplianceMetadataForProperty})">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Compliance.ComplianceMetadataResolver"/>.
            </summary>
            <param name="typeProviders">Type providers.</param>
            <param name="propertyProviders">Property providers.</param>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataResolver.HasMetadataFor(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataResolver.HasMetadataFor(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataResolver.GetMetadataFor(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataResolver.GetMetadataFor(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Compliance.ComplianceMetadataType">
            <summary>
            Represents a type of compliance metadata.
            </summary>
            <param name="Value">Underlying value.</param>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataType.#ctor(System.Guid)">
            <summary>
            Represents a type of compliance metadata.
            </summary>
            <param name="Value">Underlying value.</param>
        </member>
        <member name="F:Cratis.Compliance.ComplianceMetadataType.PII">
            <summary>
            Personal Identifiable Information according to the definition in GDPR.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataType.op_Implicit(System.String)~Cratis.Compliance.ComplianceMetadataType">
            <summary>
            Convert from a <see cref="T:System.String"/> representation of a <see cref="T:System.Guid"/> to <see cref="T:Cratis.Compliance.ComplianceMetadataType"/>.
            </summary>
            <param name="value"><see cref="T:System.String"/> representation.</param>
        </member>
        <member name="M:Cratis.Compliance.ComplianceMetadataType.op_Implicit(System.Guid)~Cratis.Compliance.ComplianceMetadataType">
            <summary>
            Convert from <see cref="T:System.Guid"/> to <see cref="T:Cratis.Compliance.ComplianceMetadataType"/>.
            </summary>
            <param name="value))"><see cref="T:System.Guid"/> to convert from.</param>
        </member>
        <member name="T:Cratis.Compliance.ICanProvideComplianceMetadataForProperty">
            <summary>
            Defines a provider of <see cref="T:Cratis.Compliance.ComplianceMetadata"/> for <see cref="T:System.Reflection.PropertyInfo">types</see>.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.ICanProvideComplianceMetadataForProperty.CanProvide(System.Reflection.PropertyInfo)">
            <summary>
            Checks whether or not it can provide for the type.
            </summary>
            <param name="property"><see cref="T:System.Type"/> to check for.</param>
            <returns>True if it can provide, false if not.</returns>
        </member>
        <member name="M:Cratis.Compliance.ICanProvideComplianceMetadataForProperty.Provide(System.Reflection.PropertyInfo)">
            <summary>
            Provide the metadata for the type.
            </summary>
            <param name="property"><see cref="T:System.Type"/> to provide for.</param>
            <returns>Provided <see cref="T:Cratis.Compliance.ComplianceMetadata"/>.</returns>
        </member>
        <member name="T:Cratis.Compliance.ICanProvideComplianceMetadataForType">
            <summary>
            Defines a provider of <see cref="T:Cratis.Compliance.ComplianceMetadata"/> for <see cref="T:System.Type">types</see>.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.ICanProvideComplianceMetadataForType.CanProvide(System.Type)">
            <summary>
            Checks whether or not it can provide for the type.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check for.</param>
            <returns>True if it can provide, false if not.</returns>
        </member>
        <member name="M:Cratis.Compliance.ICanProvideComplianceMetadataForType.Provide(System.Type)">
            <summary>
            Provide the metadata for the type.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to provide for.</param>
            <returns>Provided <see cref="T:Cratis.Compliance.ComplianceMetadata"/>.</returns>
        </member>
        <member name="T:Cratis.Compliance.IComplianceMetadataResolver">
            <summary>
            Defines a resolver of <see cref="T:Cratis.Compliance.ComplianceMetadata"/> for types and properties.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.IComplianceMetadataResolver.HasMetadataFor(System.Type)">
            <summary>
            Check whether or not a specific <see cref="T:System.Type"/> has any <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with it.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if it has, false if not.</returns>
        </member>
        <member name="M:Cratis.Compliance.IComplianceMetadataResolver.HasMetadataFor(System.Reflection.PropertyInfo)">
            <summary>
            Check whether or not a specific <see cref="T:System.Reflection.PropertyInfo"/> has any <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with it.
            </summary>
            <param name="property"><see cref="T:System.Reflection.PropertyInfo"/> to check.</param>
            <returns>True if it has, false if not.</returns>
        </member>
        <member name="M:Cratis.Compliance.IComplianceMetadataResolver.GetMetadataFor(System.Type)">
            <summary>
            Get the <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with a <see cref="T:System.Type"/>.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to get for.</param>
            <returns>Collection of <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with the type.</returns>
        </member>
        <member name="M:Cratis.Compliance.IComplianceMetadataResolver.GetMetadataFor(System.Reflection.PropertyInfo)">
            <summary>
            Get the <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with a <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <param name="property"><see cref="T:System.Reflection.PropertyInfo"/> to get for.</param>
            <returns>Collection of <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with the type.</returns>
        </member>
        <member name="T:Cratis.Compliance.IHoldPII">
            <summary>
            Defines a marker interface for types to indicate the type holds PII defined by GDPR.
            </summary>
        </member>
        <member name="T:Cratis.Compliance.NoComplianceMetadataForProperty">
            <summary>
            Exception that is thrown when where is no <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with a property.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.NoComplianceMetadataForProperty.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Compliance.NoComplianceMetadataForProperty"/> class.
            </summary>
            <param name="property"><see cref="T:System.Reflection.PropertyInfo"/> that does not have compliance metadata.</param>
        </member>
        <member name="T:Cratis.Compliance.NoComplianceMetadataForType">
            <summary>
            Exception that is thrown when where is no <see cref="T:Cratis.Compliance.ComplianceMetadata"/> associated with a property.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.NoComplianceMetadataForType.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Compliance.NoComplianceMetadataForProperty"/> class.
            </summary>
            <param name="type"><see cref="T:System.Type"/> that does not have compliance metadata.</param>
        </member>
        <member name="T:Cratis.Compliance.PIIAttribute">
            <summary>
            Represents an attribute that can be used to mark classes or properties to indicate the information kept is PII according to the definition of GDPR.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.PIIAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Compliance.PIIAttribute"/> class.
            </summary>
            <param name="details">Optional details - default value is empty string.</param>
        </member>
        <member name="P:Cratis.Compliance.PIIAttribute.Details">
            <summary>
            Gets the details as to why or to what purpose/extent the type or property marked is classified as PII.
            </summary>
        </member>
        <member name="T:Cratis.Compliance.PIIConceptAs`1">
            <summary>
            Represents a <see cref="T:Cratis.Concepts.ConceptAs`1"/> that holds PII according to the definition of GDPR.
            </summary>
            <param name="Value">Underlying value.</param>
            <typeparam name="T">Type of the underlying value.</typeparam>
        </member>
        <member name="M:Cratis.Compliance.PIIConceptAs`1.#ctor(`0)">
            <summary>
            Represents a <see cref="T:Cratis.Concepts.ConceptAs`1"/> that holds PII according to the definition of GDPR.
            </summary>
            <param name="Value">Underlying value.</param>
            <typeparam name="T">Type of the underlying value.</typeparam>
        </member>
        <member name="P:Cratis.Compliance.PIIConceptAs`1.Details">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Compliance.PIIMetadataProvider">
            <summary>
            Represents a metadata provider for PII.
            </summary>
        </member>
        <member name="M:Cratis.Compliance.PIIMetadataProvider.CanProvide(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Compliance.PIIMetadataProvider.CanProvide(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Compliance.PIIMetadataProvider.Provide(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Compliance.PIIMetadataProvider.Provide(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Concepts.ConceptAs`1">
            <summary>
            Expresses a Concept as a another type, usually a primitive such as Guid, Int or String.
            </summary>
            <typeparam name="T">Type of the concept.</typeparam>
        </member>
        <member name="M:Cratis.Concepts.ConceptAs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of <see cref="T:Cratis.Concepts.ConceptAs`1"/>.
            </summary>
            <param name="value">Value to initialize the concept with.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when incoming value is null.</exception>
        </member>
        <member name="P:Cratis.Concepts.ConceptAs`1.Value">
            <summary>
            Gets or inits the underlying value for the instance.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.ConceptAs`1.op_Implicit(Cratis.Concepts.ConceptAs{`0})~`0">
            <summary>
            Implicitly convert from the <see cref="T:Cratis.Concepts.ConceptAs`1"/> to the value of the type given.
            </summary>
            <param name="value"><see cref="T:Cratis.Concepts.ConceptAs`1"/> to convert from.</param>
        </member>
        <member name="M:Cratis.Concepts.ConceptAs`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Concepts.ConceptAsDictionaryJsonConverter">
            <summary>
            Represents a <see cref="T:Newtonsoft.Json.JsonConverter"/> that can serialize and deserialize a <see cref="T:System.Collections.Generic.IDictionary`2">dictionary</see> of <see cref="T:Cratis.Concepts.ConceptAs`1"/>
            </summary>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsDictionaryJsonConverter.CanConvert(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsDictionaryJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsDictionaryJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Concepts.ConceptAsJsonConverter">
            <summary>
            Represents a <see cref="T:Newtonsoft.Json.JsonConverter"/> for <see cref="T:Cratis.Concepts.ConceptAs`1"/>.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsJsonConverter.CanConvert(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Concepts.ConceptAsTypeConverter`2">
            <summary>
            Represents a <see cref="T:System.ComponentModel.TypeConverter"/> for handling conversion of concept as represented as its value type.
            </summary>
            <typeparam name="TConcept">Type of concept.</typeparam>
            <typeparam name="TValue">Type of value.</typeparam>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsTypeConverter`2.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Concepts.ConceptAsTypeConverter`2.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Concepts.ConceptExtensions">
            <summary>
            Provides extensions related to <see cref="T:System.Type">types</see> and others related to <see cref="T:Cratis.Concepts.ConceptAs`1"/>.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.ConceptExtensions.IsConcept(System.Type)">
            <summary>
            Check if a type is a concept or not.
            </summary>
            <param name="objectType"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is a concept, false if not.</returns>
        </member>
        <member name="M:Cratis.Concepts.ConceptExtensions.IsConcept(System.Object)">
            <summary>
            Check if an object is an instance of a concept or not.
            </summary>
            <param name="instance">instance to check.</param>
            <returns>True if object is a concept, false if not.</returns>
        </member>
        <member name="M:Cratis.Concepts.ConceptExtensions.GetConceptValueType(System.Type)">
            <summary>
            Get the type of the value inside a <see cref="T:Cratis.Concepts.ConceptAs`1"/>.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to get value type from.</param>
            <returns>The type of the <see cref="T:Cratis.Concepts.ConceptAs`1"/> value.</returns>
        </member>
        <member name="M:Cratis.Concepts.ConceptExtensions.GetConceptValue(System.Object)">
            <summary>
            Takes a Concept{T} value object as an object and returns the correct primitive value, also as an object.
            </summary>
            <param name="conceptObject">The concept as an object.</param>
            <returns>The value of the primitive type on which the concept is based.</returns>
            <exception cref="T:Cratis.Concepts.TypeIsNotAConcept">Thrown if type is not a concept.</exception>
        </member>
        <member name="T:Cratis.Concepts.ConceptFactory">
            <summary>
            Factory to create an instance of a <see cref="T:Cratis.Concepts.ConceptAs`1"/> from the Type and Underlying value.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.ConceptFactory.CreateConceptInstance(System.Type,System.Object)">
            <summary>
            Creates an instance of a <see cref="T:Cratis.Concepts.ConceptAs`1"/> given the type and underlying value.
            </summary>
            <param name="type">Type of the ConceptAs to create.</param>
            <param name="value">Value to give to this instance.</param>
            <returns>An instance of a ConceptAs with the specified value.</returns>
        </member>
        <member name="T:Cratis.Concepts.ConceptMap">
            <summary>
            Maps a concept type to the underlying primitive type.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.ConceptMap.GetConceptValueType(System.Type)">
            <summary>
            Get the type of the value in a <see cref="T:Cratis.Concepts.ConceptAs`1"/>.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to get value type from.</param>
            <returns>The type of the <see cref="T:Cratis.Concepts.ConceptAs`1"/> value.</returns>
        </member>
        <member name="T:Cratis.Concepts.StringExtensions">
            <summary>
            Provides extensions related to strings and conecpts.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.StringExtensions.ParseTo(System.String,System.Type)">
            <summary>
            Convert a string into the desired type.
            </summary>
            <param name="input">the string to parse.</param>
            <param name="type">the desired type.</param>
            <returns>value as the desired type.</returns>
        </member>
        <member name="T:Cratis.Concepts.SystemJson.ConceptAsJsonConverter`1">
            <summary>
            Represents a <see cref="T:System.Text.Json.Serialization.JsonConverter`1"/> for <see cref="T:Cratis.Concepts.ConceptAs`1"/>.
            </summary>
            <typeparam name="T">Underlying concept type.</typeparam>
        </member>
        <member name="M:Cratis.Concepts.SystemJson.ConceptAsJsonConverter`1.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Concepts.SystemJson.ConceptAsJsonConverter`1.Write(System.Text.Json.Utf8JsonWriter,`0,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Concepts.SystemJson.ConceptAsJsonConverterFactory">
            <summary>
            Represents a <see cref="T:System.Text.Json.Serialization.JsonConverterFactory"/> for providing <see cref="T:Cratis.Concepts.SystemJson.ConceptAsJsonConverter`1"/> for concept types.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.SystemJson.ConceptAsJsonConverterFactory.CanConvert(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Concepts.SystemJson.ConceptAsJsonConverterFactory.CreateConverter(System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Concepts.TypeIsNotAConcept">
            <summary>
            Exception that gets thrown when a <see cref="T:System.Type"/> is not a <see cref="T:Cratis.Concepts.ConceptAs`1"/>.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.TypeIsNotAConcept.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Concepts.TypeIsNotAConcept"/> class.
            </summary>
            <param name="type"><see cref="T:System.Type"/> that is not a concept.</param>
        </member>
        <member name="T:Cratis.Concepts.TypesExtensions">
            <summary>
            Provides extensions related to working with <see cref="T:Cratis.Types.ITypes"/>.
            </summary>
        </member>
        <member name="M:Cratis.Concepts.TypesExtensions.RegisterTypeConvertersForConcepts(Cratis.Types.ITypes)">
            <summary>
            Register type converters for all <see cref="T:Cratis.Concepts.ConceptAs`1"/> types.
            </summary>
            <param name="types"><see cref="T:Cratis.Types.ITypes"/> to extend.</param>
            <returns><see cref="T:Cratis.Types.ITypes"/> for continuation.</returns>
        </member>
        <member name="T:Cratis.Configuration.ConfigurationAttribute">
            <summary>
            Attribute used to adorn configuration objects.
            </summary>
        </member>
        <member name="M:Cratis.Configuration.ConfigurationAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Configuration.ConfigurationAttribute"/> class.
            </summary>
            <param name="fileName">Optional name of the configuration file.</param>
            <param name="optional">Whether or not the file is optional - default = false.</param>
        </member>
        <member name="P:Cratis.Configuration.ConfigurationAttribute.FileName">
            <summary>
            Gets the name of the configuration file.
            </summary>
        </member>
        <member name="P:Cratis.Configuration.ConfigurationAttribute.Optional">
            <summary>
            Gets a value indicating whether or not the file is optional.
            </summary>
        </member>
        <member name="P:Cratis.Configuration.ConfigurationAttribute.FileNameSet">
            <summary>
            Check whether or not the FileName is set.
            </summary>
        </member>
        <member name="T:Cratis.DependencyInversion.ProviderFor`1">
            <summary>
            Delegate type that is automatically hooked up with the IoC container to provide a means to get
            instances of types when your lifetime scope is longer or very different than what you depend on.
            </summary>
            <typeparam name="T">Type to provide for.</typeparam>
            <returns>Instance of the type.</returns>
            <remarks>
            This can typically be very useful when you have something that is in a singleton per tenant scope
            and your service is in singleton. Putting this in between means you get to resolve it properly in
            the correct scope. Obviously you can setup a manually registration for these things with delegates,
            but the point of this is that this is automatically hooked up for you.
            Another good usecase for this is for constructors that has a dependency which is per tenant but
            execution context might not have been established at the time, or you're unsure if you can keep
            the instance around between calls. For instance with Orleans Grains, it is Orleans that control the
            lifecycle of the grain. This would then be a good place to use this.
            </remarks>
        </member>
        <member name="T:Cratis.Dynamic.ExpandoObjectExtensions">
            <summary>
            Extension methods for working with <see cref="T:System.Dynamic.ExpandoObject"/>.
            </summary>
        </member>
        <member name="M:Cratis.Dynamic.ExpandoObjectExtensions.Clone(System.Dynamic.ExpandoObject)">
            <summary>
            Deep clone an <see cref="T:System.Dynamic.ExpandoObject"/>.
            </summary>
            <param name="original">The original <see cref="T:System.Dynamic.ExpandoObject"/>.</param>
            <returns>A cloned <see cref="T:System.Dynamic.ExpandoObject"/>.</returns>
            <remarks>
            If any of the values represents complex objects, it will not clone these
            and create new fresh instances - it will just copy these across.
            </remarks>
        </member>
        <member name="M:Cratis.Dynamic.ExpandoObjectExtensions.AsExpandoObject(System.Object)">
            <summary>
            Converts an object to a dynamic <see cref="T:System.Dynamic.ExpandoObject"/>
            </summary>
            <param name="original"></param>
            <returns>A new <see cref="T:System.Dynamic.ExpandoObject"/> representing the given object.</returns>
        </member>
        <member name="M:Cratis.Dynamic.ExpandoObjectExtensions.OverwriteWith(System.Dynamic.ExpandoObject,System.Dynamic.ExpandoObject)">
            <summary>
            Creates a clone of left and applies all content from right on top, overwriting any existing properties in left.
            </summary>
            <param name="left">The left <see cref="T:System.Dynamic.ExpandoObject"/>.</param>
            <param name="right">The right <see cref="T:System.Dynamic.ExpandoObject"/>.</param>
            <returns>A new <see cref="T:System.Dynamic.ExpandoObject"/>.</returns>
        </member>
        <member name="M:Cratis.Dynamic.ExpandoObjectExtensions.EnsurePath(System.Dynamic.ExpandoObject,Cratis.Properties.PropertyPath)">
            <summary>
            Ensure a specific path for a <see cref="T:Cratis.Properties.PropertyPath"/> exists on an <see cref="T:System.Dynamic.ExpandoObject"/>..
            </summary>
            <param name="target">Target <see cref="T:System.Dynamic.ExpandoObject"/>.</param>
            <param name="property"><see cref="T:Cratis.Properties.PropertyPath"/> to get or create for.</param>
            <returns><see cref="T:System.Dynamic.ExpandoObject"/> at property.</returns>
        </member>
        <member name="M:Cratis.Dynamic.ExpandoObjectExtensions.EnsureCollection``1(System.Dynamic.ExpandoObject,Cratis.Properties.PropertyPath)">
            <summary>
            Ensures that a collection exists for a specific <see cref="T:Cratis.Properties.PropertyPath"/>.
            </summary>
            <typeparam name="TChild">Type of child for the collection.</typeparam>
            <param name="target">Target <see cref="T:System.Dynamic.ExpandoObject"/>.</param>
            <param name="childrenProperty"><see cref="T:Cratis.Properties.PropertyPath"/> to ensure collection for.</param>
            <returns>The ensured <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
            <exception cref="T:Cratis.Properties.ChildrenPropertyIsNotEnumerable">Thrown if there is an existing property and it is not enumerable.</exception>
        </member>
        <member name="M:Cratis.Dynamic.ExpandoObjectExtensions.Contains(System.Collections.Generic.IEnumerable{System.Dynamic.ExpandoObject},Cratis.Properties.PropertyPath,System.Object)">
            <summary>
            Check if there is an item with a specific key in a collection of <see cref="T:System.Dynamic.ExpandoObject"/> items.
            </summary>
            <param name="items">Items to check.</param>
            <param name="identityProperty"><see cref="T:Cratis.Properties.PropertyPath"/> holding identity on each item.</param>
            <param name="key">The key value to check for.</param>
            <returns>True if there is an item, false if not</returns>
        </member>
        <member name="T:Cratis.Execution.CausationId">
            <summary>
            Represents an identifier for correlation.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="M:Cratis.Execution.CausationId.#ctor(System.String)">
            <summary>
            Represents an identifier for correlation.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="M:Cratis.Execution.CausationId.op_Implicit(System.String)~Cratis.Execution.CausationId">
            <summary>
            Implicitly convert from <see cref="T:System.String"/> to <see cref="T:Cratis.Execution.CausationId"/>.
            </summary>
            <param name="id"><see cref="T:System.String"/> to convert from.</param>
            <returns>A new <see cref="T:Cratis.Execution.CausationId"/>.</returns>
        </member>
        <member name="T:Cratis.Execution.CausedBy">
            <summary>
            Represents an identifier of an identity that was the root of a cause.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="M:Cratis.Execution.CausedBy.#ctor(System.Guid)">
            <summary>
            Represents an identifier of an identity that was the root of a cause.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="M:Cratis.Execution.CausedBy.op_Implicit(System.Guid)~Cratis.Execution.CausedBy">
            <summary>
            Implicitly convert from <see cref="T:System.Guid"/> to <see cref="T:Cratis.Execution.CausedBy"/>.
            </summary>
            <param name="value"><see cref="T:System.Guid"/> to convert from.</param>
        </member>
        <member name="T:Cratis.Execution.CorrelationId">
            <summary>
            Represents an identifier for correlation.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="M:Cratis.Execution.CorrelationId.#ctor(System.String)">
            <summary>
            Represents an identifier for correlation.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="M:Cratis.Execution.CorrelationId.New">
            <summary>
            Create a new <see cref="T:Cratis.Execution.CorrelationId"/> based on a new <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:Cratis.Execution.CorrelationId.op_Implicit(System.String)~Cratis.Execution.CorrelationId">
            <summary>
            Implicitly convert from <see cref="T:System.String"/> to <see cref="T:Cratis.Execution.CorrelationId"/>.
            </summary>
            <param name="id"><see cref="T:System.String"/> to convert from.</param>
            <returns>A new <see cref="T:Cratis.Execution.CorrelationId"/>.</returns>
        </member>
        <member name="T:Cratis.Execution.ExecutionContext">
            <summary>
            Represents the current context of execution.
            </summary>
            <param name="TenantId">The <see cref="P:Cratis.Execution.ExecutionContext.TenantId"/>.</param>
            <param name="CorrelationId">The <see cref="P:Cratis.Execution.ExecutionContext.CorrelationId"/>.</param>
            <param name="CausationId">The <see cref="P:Cratis.Execution.ExecutionContext.CausationId"/>.</param>
            <param name="CausedBy">The person or system that is the cause.</param>
        </member>
        <member name="M:Cratis.Execution.ExecutionContext.#ctor(Cratis.Execution.TenantId,Cratis.Execution.CorrelationId,Cratis.Execution.CausationId,Cratis.Execution.CausedBy)">
            <summary>
            Represents the current context of execution.
            </summary>
            <param name="TenantId">The <see cref="P:Cratis.Execution.ExecutionContext.TenantId"/>.</param>
            <param name="CorrelationId">The <see cref="P:Cratis.Execution.ExecutionContext.CorrelationId"/>.</param>
            <param name="CausationId">The <see cref="P:Cratis.Execution.ExecutionContext.CausationId"/>.</param>
            <param name="CausedBy">The person or system that is the cause.</param>
        </member>
        <member name="T:Cratis.Execution.ExecutionContextManager">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Execution.IExecutionContextManager"/>.
            </summary>
        </member>
        <member name="M:Cratis.Execution.ExecutionContextManager.GetCurrent">
            <summary>
            Get current <see cref="T:Cratis.Execution.ExecutionContext"/>.
            </summary>
            <returns>Current <see cref="T:Cratis.Execution.ExecutionContext"/>.</returns>
        </member>
        <member name="M:Cratis.Execution.ExecutionContextManager.SetCurrent(Cratis.Execution.ExecutionContext)">
            <summary>
            Set a <see cref="T:Cratis.Execution.ExecutionContext"/> for current call path.
            </summary>
            <param name="context"><see cref="T:Cratis.Execution.ExecutionContext"/> to set.</param>
        </member>
        <member name="P:Cratis.Execution.ExecutionContextManager.IsInContext">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Execution.ExecutionContextManager.Current">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Execution.ExecutionContextManager.Establish(Cratis.Execution.TenantId,Cratis.Execution.CorrelationId)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Execution.ExecutionContextManager.Set(Cratis.Execution.ExecutionContext)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Execution.ExecutionContextNotSet">
            <summary>
            Exception that is thrown when the <see cred="ExecutionContext"/> is not set.
            </summary>
        </member>
        <member name="M:Cratis.Execution.ExecutionContextNotSet.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:Cratis.Execution.ExecutionContextNotSet"/>.
            </summary>
        </member>
        <member name="M:Cratis.Execution.ExecutionContextNotSet.ThrowIfNotSet(Cratis.Execution.ExecutionContext)">
            <summary>
            Throw <see cref="T:Cratis.Execution.ExecutionContextNotSet"/> is not set.
            </summary>
            <param name="context"><see cref="T:Cratis.Execution.ExecutionContext"/> to check.</param>
            <exception cref="T:Cratis.Execution.ExecutionContextNotSet">Thrown if <see cref="T:Cratis.Execution.ExecutionContext"/> is not set.</exception>
        </member>
        <member name="T:Cratis.Execution.IExecutionContextManager">
            <summary>
            Defines a system for working with <see cref="T:Cratis.Execution.ExecutionContext"/>
            </summary>
        </member>
        <member name="P:Cratis.Execution.IExecutionContextManager.IsInContext">
            <summary>
            Gets whether or not we're in context.
            </summary>
        </member>
        <member name="P:Cratis.Execution.IExecutionContextManager.Current">
            <summary>
            Get the current <see cref="T:Cratis.Execution.ExecutionContext"/> for the current call path.
            </summary>
        </member>
        <member name="M:Cratis.Execution.IExecutionContextManager.Establish(Cratis.Execution.TenantId,Cratis.Execution.CorrelationId)">
            <summary>
            Establish an <see cref="T:Cratis.Execution.ExecutionContext"/> for current call path.
            </summary>
            <param name="tenantId"><see cref="T:Cratis.Execution.TenantId"/> to establish for.</param>
            <param name="correlationId"><see cref="T:Cratis.Execution.CorrelationId"/> to establish for.</param>
            <returns>Established <see cref="T:Cratis.Execution.ExecutionContext"/>.</returns>
        </member>
        <member name="M:Cratis.Execution.IExecutionContextManager.Set(Cratis.Execution.ExecutionContext)">
            <summary>
            Set a <see cref="T:Cratis.Execution.ExecutionContext"/> for current call path.
            </summary>
            <param name="context"><see cref="T:Cratis.Execution.ExecutionContext"/> to set.</param>
        </member>
        <member name="T:Cratis.Execution.SingletonAttribute">
            <summary>
            Attribute to adorn types for the IoC hookup to recognize it as a Singleton.
            </summary>
        </member>
        <member name="T:Cratis.Execution.SingletonPerTenantAttribute">
            <summary>
            Attribute to adorn types for the IoC hookup to recognize it as a Singleton.
            </summary>
        </member>
        <member name="T:Cratis.Execution.TenantId">
            <summary>
            Represents the unique identifier of a tenant in the system.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="M:Cratis.Execution.TenantId.#ctor(System.Guid)">
            <summary>
            Represents the unique identifier of a tenant in the system.
            </summary>
            <param name="Value">Actual value.</param>
        </member>
        <member name="F:Cratis.Execution.TenantId.NotSet">
            <summary>
            The value used when a <see cref="T:Cratis.Execution.TenantId"/> is not set.
            </summary>
        </member>
        <member name="F:Cratis.Execution.TenantId.Development">
            <summary>
            The development tenant used during development as a fallback.
            </summary>
        </member>
        <member name="M:Cratis.Execution.TenantId.op_Implicit(System.Guid)~Cratis.Execution.TenantId">
            <summary>
            Implicitly convert from <see cref="T:System.Guid"/> to <see cref="T:Cratis.Execution.TenantId"/>.
            </summary>
            <param name="id"><see cref="T:System.Guid"/> to convert from.</param>
            <returns>A new <see cref="T:Cratis.Execution.TenantId"/>.</returns>
        </member>
        <member name="M:Cratis.Execution.TenantId.op_Implicit(System.String)~Cratis.Execution.TenantId">
            <summary>
            Implicitly convert from <see cref="T:System.String"/> representation of a <see cref="T:System.Guid"/> to <see cref="T:Cratis.Execution.TenantId"/>.
            </summary>
            <param name="id"><see cref="T:System.String"/> to convert from.</param>
            <returns>A new <see cref="T:Cratis.Execution.TenantId"/>.</returns>
        </member>
        <member name="T:Cratis.Objects.ObjectExtensions">
            <summary>
            Extension methods for any object.
            </summary>
        </member>
        <member name="M:Cratis.Objects.ObjectExtensions.Clone``1(``0)">
            <summary>
            Deep clone an object.
            </summary>
            <param name="source">Object clone.</param>
            <typeparam name="T">Type of object to clone.</typeparam>
            <returns>Cloned instance.</returns>
        </member>
        <member name="M:Cratis.Objects.ObjectExtensions.EnsurePath(System.Object,Cratis.Properties.PropertyPath)">
            <summary>
            Ensure a <see cref="T:Cratis.Properties.PropertyPath"/> on an object.
            </summary>
            <param name="source">Object to ensure on.</param>
            <param name="propertyPath"><see cref="T:Cratis.Properties.PropertyPath"/> to ensure.</param>
            <returns>Instance of the last segment in the path.</returns>
            <exception cref="T:Cratis.Properties.UnableToResolvePropertyPathOnType">Thrown if not able to resolve parts of the property path on the type.</exception>
        </member>
        <member name="T:Cratis.Properties.ChildrenPropertyIsNotEnumerable">
            <summary>
            Exception that is thrown when a children property is not enumerable.
            </summary>
        </member>
        <member name="M:Cratis.Properties.ChildrenPropertyIsNotEnumerable.#ctor(Cratis.Properties.PropertyPath)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Properties.ChildrenPropertyIsNotEnumerable"/> class.
            </summary>
            <param name="property"><see cref="T:Cratis.Properties.PropertyPath"/> that is wrong type.</param>
        </member>
        <member name="M:Cratis.Properties.ChildrenPropertyIsNotEnumerable.#ctor(System.Type,Cratis.Properties.PropertyPath)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Properties.ChildrenPropertyIsNotEnumerable"/> class.
            </summary>
            <param name="type">Type that is the root of the <see cref="T:Cratis.Properties.PropertyPath"/>.</param>
            <param name="property"><see cref="T:Cratis.Properties.PropertyPath"/> that is wrong type.</param>
        </member>
        <member name="T:Cratis.Properties.PropertyMapper`2">
            <summary>
            Represents the delegate of an operation that maps data from a source into a target object.
            </summary>
            <typeparam name="TSource">Type of the source.</typeparam>
            <typeparam name="TTarget">Type of the target.</typeparam>
            <param name="source">Source object.</param>
            <param name="target"><see cref="T:System.Dynamic.ExpandoObject"/> target to write to.</param>
        </member>
        <member name="T:Cratis.Properties.PropertyPath">
            <summary>
            Represents an encapsulation of a property in the system - used for accessing properties on objects.
            </summary>
        </member>
        <member name="F:Cratis.Properties.PropertyPath.Root">
            <summary>
            Represents the root path.
            </summary>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.op_Implicit(Cratis.Properties.PropertyPath)~System.String">
            <summary>
            Implicitly convert from <see cref="T:Cratis.Properties.PropertyPath"/> to <see cref="T:System.String"/>
            </summary>
            <param name="property"><see cref="T:Cratis.Properties.PropertyPath"/> to convert from.</param>
            <returns>Converted path.</returns>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.op_Implicit(System.String)~Cratis.Properties.PropertyPath">
            <summary>
            Implicitly convert from <see cref="T:System.String"/> to a <see cref="T:Cratis.Properties.PropertyPath"/>.
            </summary>
            <param name="path">The path of the property.</param>
            <returns>Converted <see cref="T:Cratis.Properties.PropertyPath"/>.</returns>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Properties.PropertyPath"/> class.
            </summary>
            <param name="path">Path to the property relative within an object.</param>
        </member>
        <member name="P:Cratis.Properties.PropertyPath.Path">
            <summary>
            Gets the full path of the property.
            </summary>
        </member>
        <member name="P:Cratis.Properties.PropertyPath.Segments">
            <summary>
            Gets the segments the full property path consists of.
            </summary>
        </member>
        <member name="P:Cratis.Properties.PropertyPath.LastSegment">
            <summary>
            Gets the last segment of the path.
            </summary>
        </member>
        <member name="P:Cratis.Properties.PropertyPath.IsRoot">
            <summary>
            Gets whether or not this is the root path.
            </summary>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.GetValue(System.Object)">
            <summary>
            Gets the value at the path of the property.
            </summary>
            <param name="target">Object to get from.</param>
            <returns>Value, if any.</returns>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.SetValue(System.Object,System.Object)">
            <summary>
            Set a specific value at the path of the property.
            </summary>
            <param name="target">Object to set to.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.GetPropertyInfoFor``1">
            <summary>
            Get the corresponding <see cref="T:System.Reflection.PropertyInfo"/> for the full path from the root type.
            </summary>
            <typeparam name="TRoot">Type of root.</typeparam>
            <returns>The <see cref="T:System.Reflection.PropertyInfo"/>.</returns>
            <exception cref="T:Cratis.Properties.UnableToResolvePropertyPathOnType">Thrown if not able to resolve the property path on the type.</exception>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.GetPropertyInfoFor(System.Type)">
            <summary>
            Get the corresponding <see cref="T:System.Reflection.PropertyInfo"/> for the full path from the root type.
            </summary>
            <param name="rootType">Type of root.</param>
            <returns>The <see cref="T:System.Reflection.PropertyInfo"/>.</returns>
            <exception cref="T:Cratis.Properties.UnableToResolvePropertyPathOnType">Thrown if not able to resolve the property path on the type.</exception>
        </member>
        <member name="M:Cratis.Properties.PropertyPath.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Properties.PropertyPathJsonConverter">
            <summary>
            Represents a <see cref="T:Newtonsoft.Json.JsonConverter"/> for converting <see cref="T:Cratis.Properties.PropertyPath"/>.
            </summary>
        </member>
        <member name="M:Cratis.Properties.PropertyPathJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,Cratis.Properties.PropertyPath,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Properties.PropertyPathJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,Cratis.Properties.PropertyPath,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Properties.UnableToResolvePropertyPathOnType">
            <summary>
            Exception that is thrown when property path is not possible to be resolved on a type.
            </summary>
        </member>
        <member name="M:Cratis.Properties.UnableToResolvePropertyPathOnType.#ctor(System.Type,Cratis.Properties.PropertyPath)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Properties.UnableToResolvePropertyPathOnType"/> class.
            </summary>
            <param name="type">Type that does not hold the property path.</param>
            <param name="path">The <see cref="T:Cratis.Properties.PropertyPath"/> that is not possible to resolve.</param>
        </member>
        <member name="T:Cratis.Properties.ValueProvider`1">
            <summary>
            Represents the delegate for providing a value from an object.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source">Source to get from.</param>
            <returns>Resolved value.</returns>
        </member>
        <member name="T:Cratis.Reactive.IObservableCollection`1">
            <summary>
            Defines an observable collection.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="E:Cratis.Reactive.IObservableCollection`1.Cleared">
            <summary>
            The event that is fired if the collection is cleared.
            </summary>
        </member>
        <member name="P:Cratis.Reactive.IObservableCollection`1.Added">
            <summary>
            Gets the added <see cref="T:System.IObservable`1"/>.
            </summary>
        </member>
        <member name="P:Cratis.Reactive.IObservableCollection`1.Removed">
            <summary>
            Gets the removed <see cref="T:System.IObservable`1"/>.
            </summary>
        </member>
        <member name="T:Cratis.Reactive.ObservableCollection`1">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Reactive.IObservableCollection`1"/>.
            </summary>
            <typeparam name="TItem">Type of item.</typeparam>
        </member>
        <member name="E:Cratis.Reactive.ObservableCollection`1.Cleared">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Reactive.ObservableCollection`1.Added">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Reactive.ObservableCollection`1.Removed">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Reactive.ObservableCollection`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Reactive.ObservableCollection`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Reactive.ObservableCollection`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Reactive.ObservableCollection`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Reactive.ObservableCollection`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Reactive.ObservableCollection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Reactive.ObservableCollection`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Reactive.ObservableCollection`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Reactive.ObservableCollection`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Reactive.ObservableCollectionCleared">
            <summary>
            Delegate representing the action of an <see cref="T:Cratis.Reactive.IObservableCollection`1"/> being cleared.
            </summary>
        </member>
        <member name="T:Cratis.Reflection.ExpressionExtensions">
            <summary>
            Provides methods for working with expressions.
            </summary>
        </member>
        <member name="P:Cratis.Reflection.ExpressionExtensions.Unwrap">
            <summary>
            A Func to extract a member expression from an Expression.
            </summary>
        </member>
        <member name="M:Cratis.Reflection.ExpressionExtensions.GetMethodInfo(System.Linq.Expressions.Expression)">
            <summary>
            Get <see cref="T:System.Reflection.MethodInfo">MethodInfo</see> from an <see cref="T:System.Linq.Expressions.Expression">expression</see> - if any.
            </summary>
            <param name="expression"><see cref="T:System.Linq.Expressions.Expression">Expression</see> to get MethodInfo from.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo">MethodInfo</see> found, null if did not find one.</returns>
        </member>
        <member name="M:Cratis.Reflection.ExpressionExtensions.GetMethodArguments(System.Linq.Expressions.Expression)">
            <summary>
            Get all argument instances from a method expression.
            </summary>
            <param name="expression"><see cref="T:System.Linq.Expressions.Expression"/> to get argument instances from.</param>
            <returns>Array of argument instances.</returns>
        </member>
        <member name="M:Cratis.Reflection.ExpressionExtensions.GetMemberExpression(System.Linq.Expressions.Expression)">
            <summary>
            Get <see cref="T:System.Linq.Expressions.MemberExpression">MemberExpression</see> from an <see cref="T:System.Linq.Expressions.Expression">expression</see> - if any.
            </summary>
            <param name="expression"><see cref="T:System.Linq.Expressions.Expression">Expression</see> to get <see cref="T:System.Linq.Expressions.MemberExpression">MemberExpression</see> from.</param>
            <returns><see cref="T:System.Linq.Expressions.MemberExpression">MemberExpression</see> instance, null if there is none.</returns>
        </member>
        <member name="M:Cratis.Reflection.ExpressionExtensions.GetFieldInfo(System.Linq.Expressions.Expression)">
            <summary>
            Get <see cref="T:System.Reflection.FieldInfo">FieldInfo</see> from an <see cref="T:System.Linq.Expressions.Expression">Expression</see> - if any.
            </summary>
            <param name="expression"><see cref="T:System.Linq.Expressions.Expression">Expression</see> to get <see cref="T:System.Reflection.FieldInfo">FieldInfo</see> from.</param>
            <returns><see cref="T:System.Reflection.FieldInfo">FieldInfo</see> instance, null if there is none.</returns>
        </member>
        <member name="M:Cratis.Reflection.ExpressionExtensions.GetPropertyInfo(System.Linq.Expressions.Expression)">
            <summary>
            Get <see cref="T:System.Reflection.PropertyInfo">PropertyInfo</see> from an <see cref="T:System.Linq.Expressions.Expression">Expression</see> - if any.
            </summary>
            <param name="expression"><see cref="T:System.Linq.Expressions.Expression">Expression</see> to get <see cref="T:System.Reflection.PropertyInfo">PropertyInfo</see> from.</param>
            <returns><see cref="T:System.Reflection.PropertyInfo">PropertyInfo</see> instance, null if there is none.</returns>
        </member>
        <member name="M:Cratis.Reflection.ExpressionExtensions.GetInstance(System.Linq.Expressions.Expression)">
            <summary>
            Get an instance reference from an <see cref="T:System.Linq.Expressions.Expression">Expression</see> - if any.
            </summary>
            <param name="expression"><see cref="T:System.Linq.Expressions.Expression">Expression</see> to get an instance from.</param>
            <returns>The instance, null if there is none.</returns>
        </member>
        <member name="M:Cratis.Reflection.ExpressionExtensions.GetInstance``1(System.Linq.Expressions.Expression)">
            <summary>
            Get an instance reference from an <see cref="T:System.Linq.Expressions.Expression">Expression</see>, with a specific type - if any.
            </summary>
            <typeparam name="T">Type of the instance.</typeparam>
            <param name="expression"><see cref="T:System.Linq.Expressions.Expression">Expression</see> to get an instance from.</param>
            <returns>The instance, null if there is none.</returns>
        </member>
        <member name="T:Cratis.Reflection.ITypeInfo">
            <summary>
            Defines information for types.
            </summary>
        </member>
        <member name="P:Cratis.Reflection.ITypeInfo.HasDefaultConstructor">
            <summary>
            Gets a value indicating whether or not the type has a default constructor that takes no arguments.
            </summary>
        </member>
        <member name="T:Cratis.Reflection.MethodCalls">
            <summary>
            Extension methods for calling methods on objects using reflection.
            </summary>
        </member>
        <member name="M:Cratis.Reflection.MethodCalls.CallGenericMethod``5(``1,System.Linq.Expressions.Expression{System.Func{``1,System.Func{``2,``3,``4,``0}}},``2,``3,``4,System.Type[])">
            <summary>
            Call generic method.
            </summary>
            <param name="target">Target to call method on.</param>
            <param name="method">Signature of the method.</param>
            <param name="param1">First parameter.</param>
            <param name="param2">Second parameter.</param>
            <param name="param3">Third parameter.</param>
            <param name="genericArguments">Generic arguments.</param>
            <typeparam name="TOut">Output type.</typeparam>
            <typeparam name="T">Type of target.</typeparam>
            <typeparam name="T1">Type of first parameter.</typeparam>
            <typeparam name="T2">Type of second parameter.</typeparam>
            <typeparam name="T3">Type of third parameter.</typeparam>
            <returns>The result from the method call.</returns>
        </member>
        <member name="M:Cratis.Reflection.MethodCalls.CallGenericMethod``4(``1,System.Linq.Expressions.Expression{System.Func{``1,System.Func{``2,``3,``0}}},``2,``3,System.Type[])">
            <summary>
            Call generic method.
            </summary>
            <param name="target">Target to call method on.</param>
            <param name="method">Signature of the method.</param>
            <param name="param1">First parameter.</param>
            <param name="param2">Second parameter.</param>
            <param name="genericArguments">Generic arguments.</param>
            <typeparam name="TOut">Output type.</typeparam>
            <typeparam name="T">Type of target.</typeparam>
            <typeparam name="T1">Type of first parameter.</typeparam>
            <typeparam name="T2">Type of second parameter.</typeparam>
            <returns>The result from the method call.</returns>
        </member>
        <member name="M:Cratis.Reflection.MethodCalls.CallGenericMethod``3(``1,System.Linq.Expressions.Expression{System.Func{``1,System.Func{``2,``0}}},``2,System.Type[])">
            <summary>
            Call generic method.
            </summary>
            <param name="target">Target to call method on.</param>
            <param name="method">Signature of the method.</param>
            <param name="param">Method parameter.</param>
            <param name="genericArguments">Generic arguments.</param>
            <typeparam name="TOut">Output type.</typeparam>
            <typeparam name="T">Type of target.</typeparam>
            <typeparam name="T1">Type of parameter.</typeparam>
            <returns>The result from the method call.</returns>
        </member>
        <member name="M:Cratis.Reflection.MethodCalls.CallGenericMethod``2(``1,System.Linq.Expressions.Expression{System.Func{``1,System.Func{``0}}},System.Type[])">
            <summary>
            Call generic method.
            </summary>
            <param name="target">Target to call method on.</param>
            <param name="method">Signature of the method.</param>
            <param name="genericArguments">Generic arguments.</param>
            <typeparam name="TOut">Output type.</typeparam>
            <typeparam name="T">Type of target.</typeparam>
            <returns>The result from the method call.</returns>
        </member>
        <member name="T:Cratis.Reflection.MethodExtensions">
            <summary>
            Provides a set of methods for working with methods, such as <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
        </member>
        <member name="M:Cratis.Reflection.MethodExtensions.IsAsync(System.Reflection.MethodInfo)">
            <summary>
            Check whether or not a <see cref="T:System.Reflection.MethodInfo"/> is async or not.
            </summary>
            <param name="methodInfo"><see cref="T:System.Reflection.MethodInfo"/> to check.</param>
            <returns>True if is async, false if not.</returns>
        </member>
        <member name="T:Cratis.Reflection.TypeConstructorExtensions">
            <summary>
            Provides a set of methods for working with <see cref="T:System.Type">types</see> and their constructors.
            </summary>
        </member>
        <member name="M:Cratis.Reflection.TypeConstructorExtensions.HasDefaultConstructor(System.Type)">
            <summary>
            Check if a type has a default constructor that does not take any arguments.
            </summary>
            <param name="type">Type to check.</param>
            <returns>true if it has a default constructor, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeConstructorExtensions.HasNonDefaultConstructor(System.Type)">
            <summary>
            Check if a type has a non default constructor.
            </summary>
            <param name="type">Type to check.</param>
            <returns>true if it has a non default constructor, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeConstructorExtensions.GetDefaultConstructor(System.Type)">
            <summary>
            Get the default constructor from a type.
            </summary>
            <param name="type">Type to get from.</param>
            <returns>The default <see cref="T:System.Reflection.ConstructorInfo"/>.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeConstructorExtensions.GetNonDefaultConstructor(System.Type)">
            <summary>
            Get the non default constructor, assuming there is only one.
            </summary>
            <param name="type">Type to get from.</param>
            <returns>The <see cref="T:System.Reflection.ConstructorInfo"/> for the constructor.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeConstructorExtensions.GetNonDefaultConstructor(System.Type,System.Type[])">
            <summary>
            Get the non default constructor matching the types.
            </summary>
            <param name="type">Type to get from.</param>
            <param name="parameterTypes">Types for matching the parameters.</param>
            <returns>The <see cref="T:System.Reflection.ConstructorInfo"/> for the constructor.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeConstructorExtensions.GetNonDefaultConstructorWithGreatestNumberOfParameters(System.Type)">
            <summary>
            Get the non default constructor with the greatest number of parameters.
            Should be used with care. Constructors are not ordered, so if there are multiple constructors with the
            same number of parameters, it is indeterminate which will be returned.
            </summary>
            <param name="type">Type to get from.</param>
            <returns>The <see cref="T:System.Reflection.ConstructorInfo"/> for the constructor.</returns>
        </member>
        <member name="T:Cratis.Reflection.TypeExtensions">
            <summary>
            Provides a set of methods for working with <see cref="T:System.Type">types</see>.
            </summary>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.HasAttribute``1(System.Type)">
            <summary>
            Check if a type has an attribute associated with it.
            </summary>
            <typeparam name="T">Attribute type to check for.</typeparam>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if there is an attribute, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsNullable(System.Type)">
            <summary>
            Check if a type is nullable or not.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is nullable, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.GetNullableType(System.Type)">
            <summary>
            Get the underlying nullable type.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to get from</param>
            <returns>Underlying nullable type.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsNumericType(System.Type)">
            <summary>
            Check if a type is a number or not.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is numeric, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsEnumerable(System.Type)">
            <summary>
            Check if a type is enumerable. Note that string is an IEnumerable, but in this case the string is excluded.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is enumerable, false if not an enumerable.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.Is``1(System.Type)">
            <summary>
            Check if the type is of the type specified in the generic param.
            </summary>
            <typeparam name="T">Type of the instance.</typeparam>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is a date, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsDate(System.Type)">
            <summary>
            Check if a type is a Date or not.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is a date, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsDateTimeOffset(System.Type)">
            <summary>
            Check if a type is a DateTimeOffset or not.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is a date, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsBoolean(System.Type)">
            <summary>
            Check if a type is a Boolean or not.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is a boolean, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsString(System.Type)">
            <summary>
            Check if a type is a String or not.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is a string, false otherwise.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsGuid(System.Type)">
            <summary>
            Check if a type is a Guid or not.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if type is a Guid, false otherwise.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.GetSettableProperties(System.Type)">
            <summary>
            Gets all the public properties with setters.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to get settable properties for.</param>
            <returns>Settable <see cref="T:System.Reflection.PropertyInfo">properties</see>.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.GetEnumerableElementType(System.Type)">
            <summary>
            Gets the element type of an enumerable.
            </summary>
            <param name="enumerableType">The <see cref="T:System.Type">type of the enumerable</see>.</param>
            <returns>Enumerable element <see cref="T:System.Type"/>.</returns>
            <remarks>
            https://stackoverflow.com/questions/906499/getting-type-t-from-ienumerablet.
            </remarks>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.HasInterface``1(System.Type)">
            <summary>
            Check if a type implements a specific interface.
            </summary>
            <typeparam name="T">Interface to check for.</typeparam>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if the type implements the interface, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.HasInterface(System.Type,System.Type)">
            <summary>
            Check if a type implements a specific interface.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <param name="interfaceType">Interface to check for.</param>
            <returns>True if the type implements the interface, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsDerivedFromOpenGeneric(System.Type,System.Type)">
            <summary>
            Check if a type derives from an open generic type.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <param name="openGenericType">Open generic <see cref="T:System.Type"/> to check for.</param>
            <returns>True if type matches the open generic <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.ImplementsOpenGeneric(System.Type,System.Type)">
            <summary>
            Check if a type implements an open generic type.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <param name="openGenericType">Open generic <see cref="T:System.Type"/> to check for.</param>
            <returns>True if type implements the open generic <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.IsAPrimitiveType(System.Type)">
            <summary>
            Check if a type is a "primitve" type.  This is not just dot net primitives but basic types like string, decimal, datetime,
            that are not classified as primitive types.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if <see cref="T:System.Type"/> is a primitive type.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            Check if a type implements another type - supporting interfaces, abstract types, with or without generics.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <param name="super">Super / parent type to check against.</param>
            <returns>True if derived, false if not.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.AllBaseAndImplementingTypes(System.Type)">
            <summary>
            Returns all base types of a given type, both open and closed generic (if any), including itself.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to get for.</param>
            <returns>All base and implementing <see cref="T:System.Type">types</see>.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.HasVisibleProperties(System.Type)">
            <summary>
            Indicates whether the Type has any public properties to get or set state.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to check.</param>
            <returns>True if there are public properties (get or set), false otherwise.</returns>
        </member>
        <member name="M:Cratis.Reflection.TypeExtensions.GetTypeInfoDetails(System.Type)">
            <summary>
            Get <see cref="T:Cratis.Reflection.ITypeInfo"/> from <see cref="T:System.Type"/>.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to get from.</param>
            <returns>The <see cref="T:Cratis.Reflection.ITypeInfo"/>.</returns>
        </member>
        <member name="T:Cratis.Reflection.TypeInfo`1">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Reflection.ITypeInfo"/>.
            </summary>
            <typeparam name="T">Type it holds info for.</typeparam>
        </member>
        <member name="F:Cratis.Reflection.TypeInfo`1.Instance">
            <summary>
            Gets a singleton instance of the TypeInfo.
            </summary>
        </member>
        <member name="P:Cratis.Reflection.TypeInfo`1.HasDefaultConstructor">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Schemas.ComplianceMetadataSchemaProcessor">
            <summary>
            Represents an implementation of <see cref="T:NJsonSchema.Generation.ISchemaProcessor"/> for handling compliance metadata.
            </summary>
        </member>
        <member name="M:Cratis.Schemas.ComplianceMetadataSchemaProcessor.#ctor(Cratis.Compliance.IComplianceMetadataResolver)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Schemas.ComplianceMetadataSchemaProcessor"/> class.
            </summary>
            <param name="metadataResolver"><see cref="T:Cratis.Compliance.IComplianceMetadataResolver"/> for resolving metadata.</param>
        </member>
        <member name="M:Cratis.Schemas.ComplianceMetadataSchemaProcessor.Process(NJsonSchema.Generation.SchemaProcessorContext)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Schemas.ComplianceSchemaMetadata">
            <summary>
            Represents the compliance metadata stored in a schema.
            </summary>
            <param name="type">Type of metadata.</param>
            <param name="details">Details.</param>
        </member>
        <member name="M:Cratis.Schemas.ComplianceSchemaMetadata.#ctor(System.Guid,System.String)">
            <summary>
            Represents the compliance metadata stored in a schema.
            </summary>
            <param name="type">Type of metadata.</param>
            <param name="details">Details.</param>
        </member>
        <member name="T:Cratis.Schemas.IJsonSchemaGenerator">
            <summary>
            Defines a generator that can generate <see cref="T:NJsonSchema.JsonSchema"/>.
            </summary>
        </member>
        <member name="M:Cratis.Schemas.IJsonSchemaGenerator.Generate(System.Type)">
            <summary>
            Generate a <see cref="T:NJsonSchema.JsonSchema"/> for a specific type.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to generate for.</param>
            <returns>A generated <see cref="T:NJsonSchema.JsonSchema"/>.</returns>
        </member>
        <member name="T:Cratis.Schemas.JsonSchemaGenerator">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Schemas.IJsonSchemaGenerator"/>.
            </summary>
        </member>
        <member name="F:Cratis.Schemas.JsonSchemaGenerator.ComplianceKey">
            <summary>
            The key of the compliance extension data.
            </summary>
        </member>
        <member name="M:Cratis.Schemas.JsonSchemaGenerator.#ctor(Cratis.Compliance.IComplianceMetadataResolver)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Schemas.JsonSchemaGenerator"/> class.
            </summary>
            <param name="metadataResolver"><see cref="T:Cratis.Compliance.IComplianceMetadataResolver"/> for resolving metadata.</param>
        </member>
        <member name="M:Cratis.Schemas.JsonSchemaGenerator.Generate(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Schemas.ReflectionService">
            <summary>
            Represents an implementation of <see cref="T:NJsonSchema.Generation.IReflectionService"/> for supporting correct type description creation.
            </summary>
        </member>
        <member name="M:Cratis.Schemas.ReflectionService.GetDescription(Namotion.Reflection.ContextualType,NJsonSchema.Generation.ReferenceTypeNullHandling,NJsonSchema.Generation.JsonSchemaGeneratorSettings)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Schemas.TypeFormatSchemaProcessor">
            <summary>
            Represents an implementation of <see cref="T:NJsonSchema.Generation.ISchemaProcessor"/> for adding format information.
            </summary>
        </member>
        <member name="M:Cratis.Schemas.TypeFormatSchemaProcessor.Process(NJsonSchema.Generation.SchemaProcessorContext)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Strings.StringExtensions">
            <summary>
            Provides a set of extension methods to <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:Cratis.Strings.StringExtensions.ToCamelCase(System.String)">
            <summary>
            Convert a string into a camel cased string.
            </summary>
            <param name="stringToConvert">string to convert.</param>
            <returns>Converted string.</returns>
        </member>
        <member name="M:Cratis.Strings.StringExtensions.ToPascalCase(System.String)">
            <summary>
            Convert a string into a pascal cased string.
            </summary>
            <param name="stringToConvert">string to convert.</param>
            <returns>Converted string.</returns>
        </member>
        <member name="T:Cratis.Types.ContractToImplementorsMap">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Types.IContractToImplementorsMap"/>.
            </summary>
        </member>
        <member name="P:Cratis.Types.ContractToImplementorsMap.ContractsAndImplementors">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Types.ContractToImplementorsMap.All">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.ContractToImplementorsMap.Feed(System.Collections.Generic.IEnumerable{System.Type})">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.ContractToImplementorsMap.GetImplementorsFor``1">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.ContractToImplementorsMap.GetImplementorsFor(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Types.IContractToImplementorsMap">
            <summary>
            Defines a system that handles the relationship between contracts and their implementors.
            </summary>
            <remarks>
            A contract is considered an abstract type or an interface.
            </remarks>
        </member>
        <member name="P:Cratis.Types.IContractToImplementorsMap.ContractsAndImplementors">
            <summary>
            Gets the dictionary holding the mapping between contracts and all their implementors.
            </summary>
        </member>
        <member name="P:Cratis.Types.IContractToImplementorsMap.All">
            <summary>
            Gets all the types in the map.
            </summary>
        </member>
        <member name="M:Cratis.Types.IContractToImplementorsMap.Feed(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Feed the map with types.
            </summary>
            <param name="types"><see cref="T:System.Collections.Generic.IEnumerable`1">Types</see> to feed with.</param>
        </member>
        <member name="M:Cratis.Types.IContractToImplementorsMap.GetImplementorsFor``1">
            <summary>
            Retrieve implementors of a specific contract.
            </summary>
            <typeparam name="T">Type of contract to retrieve for.</typeparam>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1">Types</see> implementing the contract.</returns>
        </member>
        <member name="M:Cratis.Types.IContractToImplementorsMap.GetImplementorsFor(System.Type)">
            <summary>
            Retrieve implementors of a specific contract.
            </summary>
            <param name="contract"><see cref="T:System.Type"/> of contract to retrieve for.</param>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1">Types</see> implementing the contract.</returns>
        </member>
        <member name="T:Cratis.Types.IImplementationsOf`1">
            <summary>
            Defines something that can discover implementations of types enable enumeration of these.
            </summary>
            <typeparam name="T">Base type to discover for - must be an abstract class or an interface.</typeparam>
        </member>
        <member name="T:Cratis.Types.IInstancesOf`1">
            <summary>
            Defines something that can discover implementations of types and give instance of these types
            when enumerated over.
            </summary>
            <typeparam name="T">Base type to discover for - must be an abstract class or an interface.</typeparam>
        </member>
        <member name="T:Cratis.Types.ImplementationsOf`1">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Types.IImplementationsOf`1"/>.
            </summary>
            <typeparam name="T">Base type to discover for - must be an abstract class or an interface.</typeparam>
        </member>
        <member name="M:Cratis.Types.ImplementationsOf`1.#ctor(Cratis.Types.ITypes)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Types.ImplementationsOf`1"/> class.
            </summary>
            <param name="types"><see cref="T:Cratis.Types.ITypes"/> to use for finding types.</param>
        </member>
        <member name="M:Cratis.Types.ImplementationsOf`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.ImplementationsOf`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Types.InstancesOf`1">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Types.IInstancesOf`1"/>.
            </summary>
            <typeparam name="T">Base type to discover for - must be an abstract class or an interface.</typeparam>
        </member>
        <member name="M:Cratis.Types.InstancesOf`1.#ctor(Cratis.Types.ITypes,System.IServiceProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Types.InstancesOf`1"/> class.
            </summary>
            <param name="types"><see cref="T:Cratis.Types.ITypes"/> used for finding types.</param>
            <param name="serviceProvider"><see cref="T:System.IServiceProvider"/> used for managing instances of the types when needed.</param>
        </member>
        <member name="M:Cratis.Types.InstancesOf`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.InstancesOf`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Types.ITypes">
            <summary>
            Defines a system for working with types.
            </summary>
        </member>
        <member name="P:Cratis.Types.ITypes.Assemblies">
            <summary>
            Gets all assemblies used for type discovery.
            </summary>
        </member>
        <member name="P:Cratis.Types.ITypes.ProjectReferencedAssemblies">
            <summary>
            Gets all the assemblies referenced as a project reference.
            </summary>
        </member>
        <member name="P:Cratis.Types.ITypes.All">
            <summary>
            Gets returns all collected types.
            </summary>
        </member>
        <member name="M:Cratis.Types.ITypes.FindSingle``1">
            <summary>
            Find a single implementation of a basetype.
            </summary>
            <typeparam name="T">Basetype to find for.</typeparam>
            <returns>Type found.</returns>
            <remarks>
            If the base type is an interface, it will look for any types implementing the interface.
            If it is a class, it will find anyone inheriting from that class.
            </remarks>
            <exception cref="T:Cratis.Types.MultipleTypesFound">If there is more than one instance found.</exception>
        </member>
        <member name="M:Cratis.Types.ITypes.FindMultiple``1">
            <summary>
            Find multiple implementations of a basetype.
            </summary>
            <typeparam name="T">Basetype to find for.</typeparam>
            <returns>All types implementing or inheriting from the given basetype.</returns>
            <remarks>
            If the base type is an interface, it will look for any types implementing the interface.
            If it is a class, it will find anyone inheriting from that class.
            </remarks>
        </member>
        <member name="M:Cratis.Types.ITypes.FindSingle(System.Type)">
            <summary>
            Find a single implementation of a basetype.
            </summary>
            <param name="type">Basetype to find for.</param>
            <returns>Type found.</returns>
            <remarks>
            If the base type is an interface, it will look for any types implementing the interface.
            If it is a class, it will find anyone inheriting from that class.
            </remarks>
            <exception cref="T:Cratis.Types.MultipleTypesFound">If there is more than one instance found.</exception>
        </member>
        <member name="M:Cratis.Types.ITypes.FindMultiple(System.Type)">
            <summary>
            Find multiple implementations of a basetype.
            </summary>
            <param name="type">Basetype to find for.</param>
            <returns>All types implementing or inheriting from the given basetype.</returns>
            <remarks>
            If the base type is an interface, it will look for any types implementing the interface.
            If it is a class, it will find anyone inheriting from that class.
            </remarks>
        </member>
        <member name="M:Cratis.Types.ITypes.FindTypeByFullName(System.String)">
            <summary>
            Find a single type using the full name, without assembly.
            </summary>
            <param name="fullName">full name of the type to find.</param>
            <returns>The type is found, null otherwise.</returns>
        </member>
        <member name="T:Cratis.Types.MultipleTypesFound">
            <summary>
            Exception that gets thrown when multiple types are found and not allowed.
            </summary>
        </member>
        <member name="M:Cratis.Types.MultipleTypesFound.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Types.MultipleTypesFound"/> class.
            </summary>
            <param name="type">Type that multiple of it.</param>
            <param name="typesFound">The types that was found.</param>
        </member>
        <member name="T:Cratis.Types.Types">
            <summary>
            Represents an implementation of <see cref="T:Cratis.Types.ITypes"/>
            </summary>
        </member>
        <member name="M:Cratis.Types.Types.#ctor(System.String[])">
            <summary>
            Initializes a new instance of <see cref="T:Cratis.Types.Types"/>
            </summary>
            <param name="assemblyPrefixesToInclude">Optional params of assembly prefixes to include in type discovery</param>
        </member>
        <member name="P:Cratis.Types.Types.Assemblies">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Types.Types.ProjectReferencedAssemblies">
            <inheritdoc/>
        </member>
        <member name="P:Cratis.Types.Types.All">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.Types.FindSingle``1">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.Types.FindMultiple``1">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.Types.FindSingle(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.Types.FindMultiple(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Cratis.Types.Types.FindTypeByFullName(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Cratis.Types.UnableToResolveTypeByName">
            <summary>
            Exception that gets thrown when a type is not possible to be resolved by its name.
            </summary>
        </member>
        <member name="M:Cratis.Types.UnableToResolveTypeByName.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Cratis.Types.UnableToResolveTypeByName"/> class.
            </summary>
            <param name="typeName">Name of the type that was not possible to resolve.</param>
        </member>
    </members>
</doc>
